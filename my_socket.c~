#define _GNU_SOURCE

#include <stdio.h>
#include <dlfcn.h>
#include <sys/types.h>
#include <sys/socket.h>

#include "tlg.h"
#include "util.h"

#include "polarssl/config.h"

#include "polarssl/net.h"
#include "polarssl/aes.h"
#include "polarssl/dhm.h"
#include "polarssl/entropy.h"
#include "polarssl/ctr_drbg.h"
#include "polarssl/md5.h"

#define PLAINTEXT "===Hello world=="

#define CRC_SIZE 16
#define ALIGN_SIZE 8
#define TOTAL_SIZE 8
#define HEADER_SIZE 32
#define MD5_SIZE 16

#define CORRECT_CRC 100
#define WRONG_CRC 200

/* list with printfsockets for all connections */
TLG sock_list = NULL;

/* information for a single connection */

typedef struct { 
	int sockfd; 
	unsigned char* dhm_key;
	unsigned char* buf;
	int buf_size;
} TSocket;

/* debugging purpose */
void display_sock_list(TLG a) {
	while (a != NULL) {	
		TSocket* sock = (TSocket*)(a->info);
		printf("[%i %s]\n", sock->sockfd, sock->dhm_key);
    	a = a->urm;
	}
  	return;
}

/* compare socket filedescriptors */
int Comp (void *p1) { 
	int fd = ((TSocket*)(p1))->sockfd;
  	return fd;
}

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen) {
	printf("\n --- LD_PRELOAD accept --- \n");
	int connfd, ret, i;
	FILE *f;
   	size_t n, length;

        unsigned char buf[2048];
        const char *pers = "dh_server";
	
    	entropy_context entropy;
    	ctr_drbg_context ctr_drbg;
	dhm_context dhm;
	
	unsigned char md5sum[16];
	
	ssize_t (*original_recv)(int, const void *, size_t, int);	
	original_recv = dlsym(RTLD_NEXT, "recv");
	ssize_t (*original_send)(int, const void *, size_t, int);	
	original_send = dlsym(RTLD_NEXT, "send");
	
	ssize_t (*original_accept)(int, struct sockaddr*, socklen_t*);	
	original_accept = dlsym(RTLD_NEXT, "accept");
	connfd = (*original_accept)(sockfd, addr, addrlen);
	if (connfd < 0) {
		return connfd;
	}
	
	/*
    	 * 1. Setup the RNG
    	 */
   	 printf( "\n . Seeding the random number generator" );
   	 fflush( stdout );
	
	 entropy_init( &entropy );
	 if( ( ret = ctr_drbg_init( &ctr_drbg, entropy_func, &entropy,
		     			(const unsigned char *) pers,
					strlen( pers ) ) ) != 0 )
	 {	
		ret = RAND_GEN_ERROR;
	       	printf( " failed\n  ! ctr_drbg_init returned %d\n", ret );
		entropy_free( &entropy );
		return ret;
	 }
	/*
    	 * 2b. Get the DHM modulus and generator
    	 */
   	 printf( "\n . Reading DH parameters from dh_prime.txt" );
   	 fflush( stdout );

         if( ( f = fopen( "dh_prime.txt", "rb" ) ) == NULL )
   	 {
        	printf( " failed\n  ! Could not open dh_prime.txt\n" \
                "  ! Please run dh_genprime first\n\n" );
		ret = DH_PARAMS_FILE_ERROR;
        	entropy_free( &entropy );
		return ret;
   	 }

   	 if( mpi_read_file( &dhm.P, 16, f ) != 0 ||
        	 mpi_read_file( &dhm.G, 16, f ) != 0 )
    	 {
        	printf( " failed\n  ! Invalid DH parameter file\n\n" );
		fclose(f);
		ret = DH_PARAMS_FILE_ERROR;
       		dhm_free( &dhm );
    		entropy_free( &entropy );
		return ret;
    	 }
		
    	fclose( f );
	
	 /*
     	* 4. Setup the DH parameters (P,G,Ys)
     	*/
    	printf( "\n . Setting Y DH parameter" );
    	fflush( stdout );

   	memset( buf, 0, sizeof( buf ) );

    	if( ( ret = dhm_make_params( &dhm, (int) mpi_size( &dhm.P ), buf, &n,
                                 ctr_drbg_random, &ctr_drbg ) ) != 0 )
    	{
        	printf( " failed\n  ! dhm_make_params returned %d\n\n", ret );
        	dhm_free( &dhm );
    		entropy_free( &entropy );
		return ret;
 	}		
	
	printf("\n . Sending P parameter: ");
	length = 1024;
	if (mpi_write_string(&dhm.P, 16, (char*)buf, &length) == 0) {
		for( i = 0; i < length; i++ )
			printf( "%c", buf[i]);	
	}
	else 
		printf("mpi_write_string error, %i\n", length);
	fflush(stdout);
	
	ret = (*original_send)(connfd, buf, length, 0);
	if (ret < 0) {
		dhm_free( &dhm );
    		entropy_free( &entropy );
		return ret;
	}
	
	printf("\n . Sending G parameter: ");
	length = 1024;
	if (mpi_write_string(&dhm.G, 16, (char*)buf, &length) == 0) {
		for( i = 0; i < length; i++ )
			printf( "%c", buf[i]);	
	}
	else 
		printf("mpi_write_string error, %i\n", length);
	fflush(stdout);	

	ret = original_send(connfd, buf, length, 0);
	if (ret < 0) {
		dhm_free( &dhm );
    		entropy_free( &entropy );
		return ret;
	}

	printf("\n . Sending GX parameter: ");
	length = 1024;
	if (mpi_write_string(&dhm.GX, 16, (char*)buf, &length) == 0) {
		for( i = 0; i < length; i++ )
			printf( "%c", buf[i]);	
	}
	else 
		printf("mpi_write_string error, %i\n", length);
	fflush(stdout);
	
	ret = original_send(connfd, buf, length, 0);
	if (ret < 0) {
		dhm_free( &dhm );
    		entropy_free( &entropy );
		return ret;
	}

	printf( "\n . Receiving the client's public value" );
	memset( buf, 0, sizeof( buf ) );
	n = 512;
	ret = (*original_recv)(connfd, buf, n, 0);

	for( i = 0; i < n; i++ )
			printf( "%c", buf[i]);
	fflush(stdout);	
	
	if (ret < 0) {
		dhm_free( &dhm );
    		entropy_free( &entropy );
		return ret;
	}

	mpi_read_string( &dhm.GY, 16, (char*)buf);

	/*
	 * 7. Derive the shared secret: K = Ys ^ Xc mod P
     	*/
    	printf( "\n . Shared secret: " );
    	fflush( stdout );

    	if( ( ret = dhm_calc_secret( &dhm, buf, &n,
                                 ctr_drbg_random, &ctr_drbg ) ) != 0 )
    	{
        	printf( " failed\n  ! dhm_calc_secret returned %d\n\n", ret );
        	dhm_free( &dhm );
    		entropy_free( &entropy );
		return ret;
    	}

	/* allocate memory for a new connection structure */	
	TSocket* new_sock = (TSocket*)malloc(sizeof(TSocket));
	if (!new_sock) {
		ret = MEMORY_ERROR;
		dhm_free( &dhm );
    		entropy_free( &entropy );
		return ret;
	}
	new_sock->sockfd = connfd;
	new_sock->dhm_key = calloc(n, sizeof(char));
	if (!new_sock->dhm_key) {
		free (new_sock);
		ret = MEMORY_ERROR;
		dhm_free( &dhm );
    		entropy_free( &entropy );
		return ret;
	}
	memcpy(new_sock->dhm_key, buf, n);
	new_sock->buf = NULL;
	new_sock->buf_size = 0;
	InsLgP(&sock_list, new_sock);
	
    	for( n = 0; n < 256; n++ )
        	printf( "%02x", new_sock->dhm_key[n] );
		
	md5( new_sock->dhm_key, 256, md5sum );
	printf( "\n  . MD5 on DH key: " );
	for( n = 0; n < 16; n++ )
        	printf( "%02x", md5sum[n] );	
	
	fflush(stdout);
	
	/*
	printf( "\n  . Encrypting and sending the ciphertext" );
    	fflush( stdout );

    	aes_setkey_enc( &aes, new_sock->dhm_key, 256 );
    	memcpy( buf, PLAINTEXT, 16 );	

	aes_crypt_cbc( &aes, AES_ENCRYPT, 16, md5sum, buf, buf );
			
    	(*original_send)(connfd, buf, 16, 0);
	*/	
	
    	printf( "\n\n" );
	

	dhm_free( &dhm );
    	entropy_free( &entropy );
	
	return connfd;
}

int roundUp(int numToRound, int multiple) { 
	if(multiple == 0) { 
  		return numToRound; 
 	} 

 	int remainder = numToRound % multiple;
 	if (remainder == 0)
  		return numToRound;
 	return numToRound + multiple - remainder;
} 

int write(int fildes, const void *buf, size_t nbyte) {
	//printf("\n--- LD_PRELOAD write --- \n");
	ALG a_sock = CautaLG(&sock_list, Comp, fildes);
	if (*a_sock) {	
		return send(fildes, buf, nbyte, 0);
	}

	int (*original_write)(int, const void*, size_t);	
	original_write = dlsym(RTLD_NEXT, "write");	
	return (original_write)(fildes, buf, nbyte);
}

ssize_t send(int sockfd, const void *buf, size_t len, int flags) {
	printf("\n --- LD_PRELOAD send --- \n");
	int ret, newSize, align_size, total_size;;
	aes_context aes;
	unsigned char md5sum[16];
	unsigned char* newBuff;
	void *p;
	TSocket* t_sock;	
	int n;	

	ssize_t (*original_send)(int, const void *, size_t, int);	
	original_send = dlsym(RTLD_NEXT, "send");	
	
	ALG a_sock = CautaLG(&sock_list, Comp, sockfd);
	if (*a_sock) {	
		t_sock = ((TSocket*)(*a_sock)->info);
		if (len % 16) {
			newSize = roundUp(len, 16);		
			align_size = newSize - len;
		}
		else {
			newSize = len;
			align_size = 0;	
		}
		total_size = newSize + TOTAL_SIZE + ALIGN_SIZE + MD5_SIZE;
	
		if (!(t_sock->buf_size) || (t_sock->buf_size < total_size)) {
			if (t_sock->buf_size < total_size)			
				free(t_sock->buf);
			t_sock->buf = (unsigned char*)malloc(total_size * sizeof(char));
			if (!(t_sock->buf))
				return -1;
			t_sock->buf_size = total_size;
		}
		newBuff = t_sock->buf;		
		
		memset(newBuff, 0, total_size);	
		memcpy(newBuff + TOTAL_SIZE + ALIGN_SIZE + MD5_SIZE, (unsigned char*)buf, len);
		
		md5(newBuff + TOTAL_SIZE + ALIGN_SIZE + MD5_SIZE, newSize, 
				newBuff + TOTAL_SIZE + ALIGN_SIZE);
	
		printf("\n Data decoded:\n");		
		for( n = 32; n < total_size; n++ )
        		printf( "%02x", newBuff[n] );	
		
		md5( ((TSocket*)(*a_sock)->info)->dhm_key, 256, md5sum );
		aes_setkey_enc( &aes, t_sock->dhm_key, 256 );			
		aes_crypt_cbc( &aes, AES_ENCRYPT, newSize, md5sum, 
			(unsigned char*)newBuff + TOTAL_SIZE + ALIGN_SIZE + MD5_SIZE, 
			(unsigned char*)newBuff + TOTAL_SIZE + ALIGN_SIZE + MD5_SIZE);
		
		printf("\n Header:\n");		
		for( n = 16; n < 32; n++ )
        		printf( "%02x", newBuff[n] );	

		memset(newBuff, 0, 16);	
		sprintf((char*)(newBuff), "%i %i ", newSize, align_size);
		printf("\nTotal size = %i, align_size = %i\n", newSize, align_size);		
		for( n = 32; n < total_size; n++ )
        		printf( "%02x", newBuff[n] );		

		p = newBuff;
		while (total_size > 0) {
			ret = (*original_send)(sockfd, p, (size_t)(total_size), flags);
			if (ret <= 0) {
				printf("\n Error sending %i\n", ret);
				free(newBuff);
				return ret;
			}	
			total_size -= ret;
			p += ret;
		}
	}
	else {
		printf("Original send\n");
		fflush(stdout);
		ret = original_send(sockfd, buf, len, flags);
		return ret;
	}
	return len;
}

int close (int filedes) {
	printf("\n--- LD_PRELOAD close --- \n");
	ALG a_sock = CautaLG(&sock_list, Comp, filedes);
	if (*a_sock) {	
		return shutdown(filedes, 2);
	}

	int (*original_close)(int);	
	original_close = dlsym(RTLD_NEXT, "close");	
	return (original_close)(filedes);
}

int shutdown(int socket, int how) {
	printf("\n--- LD_PRELOAD shutdown --- \n");
	ALG a_sock = CautaLG(&sock_list, Comp, socket);
	if (*a_sock) {	
		TSocket* t_sock = ((TSocket*)(*a_sock)->info);
		printf("Freeing resources for socketfd: %i\n", socket);	
		free(t_sock->dhm_key);
		if (t_sock->buf)
			free(t_sock->buf);		

		ElimLgE(a_sock);	
	}
	else {
		printf("Error freeing resources for socketfd: %i\n", socket);	
	}
	
	ssize_t (*original_shutdown)(int socket, int how);	
	original_shutdown = dlsym(RTLD_NEXT, "shutdown");
	return (*original_shutdown)(socket, how);
}
